// Generated by CoffeeScript 2.5.1
(function() {
  // -*- coffee-tab-width: 4 -*-
  (function($) {
    var Data, LEVENSHTEIN_CAP, Match, WORD2VEC_THRESHOLD, Word, _jamData, cosSim, dotProd, getData, levenshtein, normalizeWord, runAlgorithm, setProgress, vecLen, zip;
    _jamData = null;
    WORD2VEC_THRESHOLD = 0.5;
    LEVENSHTEIN_CAP = 5;
    Data = class Data {
      constructor(jamWords1, wordDB1) {
        this.jamWords = jamWords1;
        this.wordDB = wordDB1;
      }

      findBestMatch(word) {
        var bestConfidence, bestDist, bestMatch, candidate, candidateVec, dist, levenshteinConfidence, sim, wordVec;
// First, an exact match is always 100% confidence
        for (candidate in this.jamWords) {
          if (word === candidate) {
            return new Match(candidate, 1.00);
          }
        }
        // Next, use the word2vec database to find a
        // high-confidence match
        bestMatch = null;
        bestConfidence = 0.0;
        wordVec = this.getWordVec(word);
        for (candidate in this.jamWords) {
          candidateVec = this.getWordVec(candidate);
          sim = cosSim(wordVec, candidateVec);
          if (sim > bestConfidence) {
            bestConfidence = sim;
            bestMatch = candidate;
          }
        }
        if (bestConfidence > WORD2VEC_THRESHOLD) {
          return new Match(bestMatch, bestConfidence);
        }
        // If that fails, try Levenshtein distance
        bestMatch = null;
        bestDist = LEVENSHTEIN_CAP + 1;
        for (candidate in this.jamWords) {
          dist = levenshtein(candidate, word);
          if (dist < bestDist) {
            bestMatch = candidate;
            bestDist = dist;
          }
        }
        if (bestDist <= LEVENSHTEIN_CAP) {
          levenshteinConfidence = (1.0 - bestDist / LEVENSHTEIN_CAP) / 2; // Max of 0.5 even with perfect
          return new Match(bestMatch, levenshteinConfidence);
        }
        return null;
      }

      getWordVec(w) {
        var ref;
        return (ref = this.wordDB[w]) != null ? ref : Array(300).fill(0.0);
      }

    };
    Match = class Match {
      constructor(word1, confidence) {
        this.word = word1;
        this.confidence = confidence;
      }

    };
    Word = class Word {
      constructor(word1, denom, score) {
        this.word = word1;
        this.denom = denom;
        this.score = score;
      }

      static fromLine(line) {
        return new Word(...line.split("\t"));
      }

    };
    getData = async function() {
      var fileContents, jamWords, wordDB;
      if (_jamData === null) {
        // Load CSV
        fileContents = (await $.ajax({
          url: "../jam_data.csv",
          dataType: "text"
        }));
        jamWords = Object.fromEntries(fileContents.split("\n").map(Word.fromLine).map(function(x) {
          return [x.word, x];
        }));
        // Load JSON
        wordDB = (await $.ajax({
          url: "../lib/wordvecs25000.json",
          dataType: "json"
        }));
        delete wordDB['__notice__'];
        _jamData = new Data(jamWords, wordDB);
      }
      return _jamData;
    };
    zip = function(a, b) {
      return a.map(function(e, i) {
        return [e, b[i]];
      });
    };
    dotProd = function(a, b) {
      return zip(a, b).map(function(x) {
        return x[0] * x[1];
      }).reduce(function(x, y) {
        return x + y;
      });
    };
    vecLen = function(a) {
      return Math.sqrt(dotProd(a, a));
    };
    cosSim = function(a, b) {
      var alen, blen;
      alen = vecLen(a);
      blen = vecLen(b);
      if (alen === 0 || blen === 0) {
        return 0;
      } else {
        return dotProd(a, b) / (alen * blen);
      }
    };
    setProgress = function(value) {
      return $("#progress").html(value);
    };
    normalizeWord = function(w) {
      return w.toLowerCase().replaceAll(/[^\w]/g, '');
    };
    // https://en.wikipedia.org/wiki/Levenshtein_distance
    levenshtein = function(a, b) {
      var d, i, j, k, l, m, n, o, p, ref, ref1, ref2, ref3, sCost;
      m = a.length;
      n = b.length;
      d = Array((m + 1) * (n + 1)).fill(0);
      for (i = k = 1, ref = m; (1 <= ref ? k <= ref : k >= ref); i = 1 <= ref ? ++k : --k) {
        d[i * (n + 1) + 0] = i;
      }
      for (j = l = 1, ref1 = n; (1 <= ref1 ? l <= ref1 : l >= ref1); j = 1 <= ref1 ? ++l : --l) {
        d[0 * (n + 1) + j] = j;
      }
      for (j = o = 1, ref2 = n; (1 <= ref2 ? o <= ref2 : o >= ref2); j = 1 <= ref2 ? ++o : --o) {
        for (i = p = 1, ref3 = m; (1 <= ref3 ? p <= ref3 : p >= ref3); i = 1 <= ref3 ? ++p : --p) {
          if (a[i - 1] === b[j - 1]) {
            sCost = 0;
          } else {
            sCost = 1;
          }
          d[i * (n + 1) + j] = Math.min(d[(i - 1) * (n + 1) + j] + 1, d[i * (n + 1) + (j - 1)] + 1, d[(i - 1) * (n + 1) + (j - 1)] + sCost); // Deletion // Insertion // Substitution
        }
      }
      return d[m * (n + 1) + n];
    };
    runAlgorithm = async function(text) {
      var bestMatches, fullData, tokenized;
      setProgress("Getting Jam data ...");
      fullData = (await getData());
      setProgress("Processing ...");
      tokenized = text.split(/\s+/).map(normalizeWord);
      bestMatches = tokenized.map(function(w) {
        return fullData.findBestMatch(w);
      });
      console.log(tokenized);
      console.log(bestMatches);
      return setProgress("Done.");
    };
    return $(function() {
      $("#rank-my-title").click(function() {
        var text;
        text = $("#title-box").val();
        return runAlgorithm(text);
      });
      return $('#title-box').keypress(function(e) {
        var key;
        key = e.which;
        if (key === 13) {
          $('#rank-my-title').click();
          false;
        }
        return true;
      });
    });
  })(jQuery);

}).call(this);
